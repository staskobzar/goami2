// Code generated by re2c 3.1, DO NOT EDIT.
// -*-go-*-
//
//go:generate re2go parser.re -o parser.go -i

package goami2

import "fmt"

// Parse AMI message as string into *Message structure
func Parse(data string) (*Message, error) {
	msg := NewMessage()
	var cur, mar int
	var ns, ne, vs, ve int
		var yyt1 int
	var yyt2 int
	var yyt3 int

	for { 
{
	var yych byte
	if (len(data) <= cur) {
		return nil, fmt.Errorf("%w: unexpected end of input", ErrAMI)
	}
	yych = data[cur]
	switch (yych) {
	case '\r':
		goto yy3
	case '0','1','2','3','4','5','6','7','8','9':
		fallthrough
	case 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
		fallthrough
	case 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z':
		yyt1 = cur
		goto yy4
	default:
		goto yy1
	}
yy1:
	cur += 1
yy2:
	{ break }
yy3:
	cur += 1
	yych = data[cur]
	switch (yych) {
	case '\n':
		goto yy5
	default:
		goto yy2
	}
yy4:
	cur += 1
	mar = cur
	yych = data[cur]
	switch (yych) {
	case '-':
		fallthrough
	case '0','1','2','3','4','5','6','7','8','9':
		fallthrough
	case 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
		fallthrough
	case 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z':
		goto yy6
	default:
		goto yy2
	}
yy5:
	cur += 1
	{ return msg, nil }
yy6:
	cur += 1
	if (len(data) <= cur) {
		return nil, fmt.Errorf("%w: unexpected end of input", ErrAMI)
	}
	yych = data[cur]
	switch (yych) {
	case '-':
		fallthrough
	case '0','1','2','3','4','5','6','7','8','9':
		fallthrough
	case 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
		fallthrough
	case 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z':
		goto yy6
	case ':':
		yyt2 = cur
		goto yy8
	default:
		goto yy7
	}
yy7:
	cur = mar
	goto yy2
yy8:
	cur += 1
	if (len(data) <= cur) {
		return nil, fmt.Errorf("%w: unexpected end of input", ErrAMI)
	}
	yych = data[cur]
	switch (yych) {
	case '\n':
		goto yy7
	case '\r':
		yyt3 = cur
		goto yy10
	case ' ':
		goto yy8
	default:
		yyt3 = cur
		goto yy9
	}
yy9:
	cur += 1
	if (len(data) <= cur) {
		return nil, fmt.Errorf("%w: unexpected end of input", ErrAMI)
	}
	yych = data[cur]
	switch (yych) {
	case '\n':
		goto yy7
	case '\r':
		goto yy10
	default:
		goto yy9
	}
yy10:
	cur += 1
	yych = data[cur]
	switch (yych) {
	case '\n':
		goto yy11
	default:
		goto yy7
	}
yy11:
	cur += 1
	ns = yyt1
	ne = yyt2
	vs = yyt3
	ve = cur
	ve += -2
	{
			msg.AddField(data[ns:ne], data[vs:ve])
		}
}

	}
	return nil, fmt.Errorf("%w: invalid input: %q", ErrAMI, data[cur:])
}

// vi: ft=go
